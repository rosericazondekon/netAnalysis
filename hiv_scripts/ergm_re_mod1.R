#' This project is part of my PhD dissertation project.
#' This section follows from the first section dedicated to the Mathematical Modeling of our co-authorship network (available [HERE](http://#)).
#'
#' The purpose of this section is the use of Exponential Random Graph Modeling (ERGM) as a  Statistical modeling to better understand and explain our malaria co-authorship network.
#' Loading the necessary packages...

#+ setup, include=FALSE,cache=FALSE
setwd('~/R/R_scripts')
library(igraph)
library(ergm)
library(parallel)
library(doParallel)
library(lubridate)
#/* library(Rmpi) */
library(snow)
library(methods)

#' Loading the variables from the last section...

#+ var-load,cache=FALSE
load('./Rdata/mnet.rda')
load('./Rdata/mnet2.rda')
load('./Rdata/mnet2.gc.rda')
load('./Rdata/auth_data.rda')
load('./Rdata/edges.rda')
load('./Rdata/mnet2.gc.rda')

# /* Loading a simplified version of the network */
mnet3 <- read_graph('./graphs/CAnet_graph.graphml', format = 'graphml')
mnet.w <- read_graph('./graphs/CAnet_weight.graphml', format = 'graphml')

#' Since this processing is going to take a lot of time, we decide to parallelize all the computations:
#+ detect-cores
# /* create a cluster with fixed number of processes */
cores=detectCores() # get number of cores
# cl <- makeCluster(cores[1]-2) #I decide to run leave 2 cores out
# registerDoParallel(cl)

#+ preproc,cache=FALSE
A <- get.adjacency(mnet3)
v.attrs <- get.data.frame(mnet3, what="vertices")
v.attrs$name <- V(mnet.w)$name
v.attrs$timesCited <- V(mnet.w)$timesCited
v.attrs$numPub <- V(mnet.w)$numPub
v.attrs$community <- V(mnet2)$community
v.attrs$degree <- V(mnet2)$degree
v.attrs$affiliation <- V(mnet.w)$place
v.attrs$city <- V(mnet.w)$affil
v.attrs$country <- V(mnet.w)$country


mnet3.simple <- network::as.network(as.matrix(A), directed=FALSE)
network::set.vertex.attribute(mnet3.simple, "timesCited", V(mnet.w)$timesCited)
network::set.vertex.attribute(mnet3.simple, "numPub", V(mnet.w)$numPub)
network::set.vertex.attribute(mnet3.simple, "community", V(mnet2)$community)
network::set.vertex.attribute(mnet3.simple, "degree", V(mnet2)$degree)
mnet3.simple
#+ formula1
my.ergm.bern <- formula(mnet3.simple ~ edges)
my.ergm.bern
mnet3.simple ~ edges
summary.statistics(my.ergm.bern)

#+ model-fitting1,cache=FALSE
t0 <- Sys.time()
my.ergm.bern.fit <- ergm(my.ergm.bern, iterations=100, 
                         control=control.ergm(parallel=cores, parallel.type="PSOCK", MCMC.samplesize=100,
                                              MCMC.interval=500, MCMLE.maxit = 100, MCMC.burnin = 20000, seed=25))
Sys.time() - t0
save(my.ergm.bern.fit, file = './Rdata/my.ergm.bern.fit.rda')

#+ model-summary,cache=FALSE
anova.ergm(my.ergm.bern.fit)
summary(my.ergm.bern.fit)


#' The coefficient of this model is 
{{my.ergm.bern.fit$coef}}
#'  and the model likelihood is 
{{my.ergm.bern.fit$mle.lik}}
#' The coefficient estimate tell us that if this network had been generated by 
#' the posited model, then the probability corresponding to the log-odds of a tie should is 
{{exp(my.ergm.bern.fit$coef)/(1 + exp(my.ergm.bern.fit$coef))}}
#' . This probability also represents the
#' fraction of possible edges that are realized. The amount of deviance explained by the model
#' is represented by two standard measures of model fit based on the likelihood (AIC and BIC),
#' and the MCMC standard error. Since this model exhibits dyadic independence,
#' MCMC estimation is not necessary, and the MCMC standard error does not apply.

#' From our section on the mathematical modeling of our network, we know that our network is not random.
#' To explore alternative hypotheses about the structure that exists and the underlying processes 
#' that generated our network, we rely on the strength of ERGM to model building.
#' 
#' From previous analyses, we have shown that prolific authors in our network tend to collaborate more.
#' We have also demonstrated a tendency towards collaboration within authors of the same clusters/communities.
#' 
#' Therefore, a good model to begin with will be a model that proposes assortative mixing i.e a greater
#' probability of authors collaborating with other authors of the same productivity 
#' (number of publications, number of times cited, or research cluster/community). Furthermore, this model
#' is convenient in that it exhibits dyadic independence. [Hunter et al. (2008b)].
#' We assume a uniform tendency towards assortative mixing within each attribute class 
#' (same tendency to collaborate for within cluster/community)
#' We fit the model using the nodecov term (main effect of a continuous covariate), and the nodematch term
#' (uniform homophily) for our categorical variable "community".

#+ formula2,cache=FALSE
mnet3.ergm <- formula(mnet3.simple ~ edges + nodecov("timesCited") + 
                        nodecov("numPub") + nodematch("community"))
summary.statistics(mnet3.ergm)

#+ model1-fitting,cache=FALSE
t0 <- Sys.time()
mod1 <- ergm(mnet3.ergm, iterations=100,
                       control=control.ergm(parallel=cores, parallel.type="PSOCK", MCMC.samplesize=100,
                                            MCMC.interval=500, MCMC.burnin = 20000, seed=25, MCMLE.maxit = 100))
save(mod1, file = './Rdata/mod1.rda')
Sys.time() - t0
summary(mod1)

#' The new model converges after 
{{mod1$mle.iterations}}
#'  iterations. We can see that all 4 terms are significant with a dramatic 
#' improvement in model likelihood. Model likelihood = 
{{mod1$mle.lik}}
#' 
#' The log-odds of a collaboration that is completely heterogeneous is 
{{round(mod1$coef[1],2)}}
#' , hence the completely heterogeneous probability of a two authors collaborating is 
{{exp(mod1$coef[1])/(1 + exp(mod1$coef[1]))}}
#' 
#' . The log-odds of a collaboration homogeneous between by communities is 
{{round(mod1$coef[4],2)}}
#'  and the homogeneous probability of two authors collaborating between the same community is 
{{exp(mod1$coef[1])/(1 + exp(mod1$coef[4]))}}
#' .
#' The log-odds of a collaboration that is homogeneous in all 4 attributes is 
{{sum(mod1$coef)}}
#'  and the associated probability is 
{{exp(sum(mod1$coef))/(1 + exp(sum(mod1$coef)))}}
#' 
#' Often times, it is typical to include the nodefactor term to capture interaction or second order effects
#' of attributes.
#' 
#' Let's run another model with this new term:

#+ formula3,cache=FALSE
mnet3.ergm2 <- formula(mnet3.simple ~ edges + nodecov("timesCited") + 
                        nodecov("numPub") + nodematch("community") + nodefactor("community"))
summary.statistics(mnet3.ergm2)

#+ model-fitting3,cache=FALSE
t0 <- Sys.time()
mod2 <- ergm(mnet3.ergm2, iterations=100,
                       control=control.ergm(parallel=cores, parallel.type="PSOCK", MCMC.samplesize=100,
                                            MCMC.interval=500, MCMC.burnin = 20000, seed=25, MCMLE.maxit = 100))
save(mod2, file = './Rdata/mod2.rda')
Sys.time() - t0
summary(mod2)

#' The new model converges after 
{{mod2$mle.iterations}}
#'  iterations. We can see that all terms are significant a 
#' model likelihood of 
{{mod2$mle.lik}}
#' .
#' Let's see what this model does and does not capture about the structure in our original data.
#' To do this, we use the model fit that we have just generated to simulate new networks at random,
#' and consider how these are similar to or different from our data

#+ simulation1,cache=FALSE
sim1 <- simulate(mod2, 
                 # burnin = 1e+6, # we may set the number of steps in the simulation chain to 1e+06
                 verbose = TRUE, seed = 25)

#' Let's examine the mixing matrix for the attribute community

#+ mixing-matrix,cache=FALSE
library(caret)
M <- mixingmatrix(sim1, "community")
confusionMatrix(M$matrix)

#' Identifying Model degeneracy
#' We first fit a triangle model

#+ degeneracy-checking,cache=FALSE
t0 <- Sys.time()
mod3 <- ergm(mnet3.simple ~ edges + triangle, maxit=100, verbose = TRUE,
             control = control.ergm(MCMLE.maxit=100, MCMC.samplesize = 1000, MCMC.interval = 1000, seed=25))
Sys.time() - t0
mod3

#+ mod3-mcmc_diag,cache=FALSE
mcmc.diagnostics(mod3)
#+ mod3-mcmc_diag_save
pdf("./figure/mod3diagnostics.pdf")
mcmc.diagnostics(mod3)
dev.off()

#' Non-degenerate dyadic dependence models
#' 
#' We explore clustering using GWESP (geometrically weighted edgewise shared partner) statistic,
#' one of the more recently proposed statistics that is closely related to the triangle (Snijders et al. (2006);
#' Robins, Snijders, Wang, Handcock, and Pattison (2007b) or Hunter (2007)). 
#' The lower the value of the scaling parameter of GWESP, the less likely the model is to be degenerate.

#+ non-degenerate,cache=FALSE
mod4.f <- formula(mnet3.simple ~ edges + gwesp(0, fixed = TRUE) + nodecov("timesCited") + 
                         nodecov("numPub") + nodematch("community") + nodefactor("community"))
t0 <- Sys.time()
mod4<- ergm(mod4.f, verbose = TRUE, control = control.ergm(MCMLE.maxit=100, MCMC.samplesize = 1000,
                                                           MCMC.interval = 1000, seed=25))
Sys.time() - t0
mod4

#+ mod4-mcmc_diag,cache=FALSE
mcmc.diagnostics(mod4)

#+ mod4-mcmc_diag_save,cache=FALSE
pdf("./figure/mod4diagnostics.pdf")
mcmc.diagnostics(mod4)
dev.off()

#' Now let's see if model 4 does a better job than mnet3.ergm.fit2
#' 

#+ mod4-sim,cache=FALSE
sim2 <- simulate(mod4, nsim = 100,
                 # burnin = 1e+6, # we may set the number of steps in the simulation chain to 1e+06
                 verbose = TRUE, seed = 25)

#' Let's assess how does the distribution of triangles in mod4 compare to the original network:

#+ mod4-comp,cache=FALSE
mod4.tridist <- sapply(sim2$networks, function(x) summary(x ~ triangle))
hist(mod4.tridist)
mnet3.tri <- summary(mnet3.simple ~ triangle)
arrows(mnet3.tri, 20, mnet3.tri, 5, col = "red", lwd = 3)
sum(fmh.tri <= model4.tridist)

#+ mod4-deg,cache=FALSE
gof4.deg <- gof(mod4 ~ degree, verbose = TRUE)
plot(gof4.deg)

#+ gof4,cache=FALSE
gof4.deg

#+ gof4-deg,cache=FALSE
pdf("./figure/gof4-deg.pdf")
plot(gof4.deg)
dev.off()

#' Let us now compare our model fit to our data on degree distribution
#+ 
# t0 <- Sys.time()
# diag <- gof(my.ergm.bern.fit, control=control.gof.ergm(parallel=cores, parallel.type="PSOCK"))
# Sys.time() - t0
# /* jpeg(filename = 'gof.my.ergm.bern.fit.jpg') */
# /* mcmc.diagnostics(my.ergm.fit) */
# /* dev.off() */
#save(diag, file = './Rdata/diag.my.ergm.bern.fit.rda')

#+ viz-diag, fig.width=20,fig.height=60
#par(mfrow=c(2, 2))
#plot(diag)
